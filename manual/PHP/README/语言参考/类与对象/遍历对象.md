# 遍历对象

`PHP` 提供了一种定义对象的方法使其可以通过单元列表来遍历，例如用 `foreach` 语句。默认情况下，所有可见属性都将被用于遍历。

```php
<?php

declare(strict_types = 1);

class Foo
{
    /**
     * Public property.
     *
     * @var string
     */
    public $public = 'public';

    /**
     * Protected property.
     *
     * @var string
     */
    protected $protected = 'protected';

    /**
     * Private property.
     *
     * @var string
     */
    private $private = 'private';

    /**
     * Print all visibility properties.
     *
     * @param  void
     * @return void
     */
    public function method()
    {
        foreach ($this as $key => $value) {
            var_dump("$key => $value");
        }
    }
}

$foo = new Foo;
foreach ($foo as $key => $value) {
    var_dump("$key => $value");
}
// string(16) "public => public"

$foo->method();
// string(16) "public => public"
// string(22) "protected => protected"
// string(18) "private => private"

```

更进一步，可以实现 `Iterator` 接口。可以让对象自行决定如何遍历以及每次遍历时那些值可用。

```php
<?php

declare(strict_types = 1);

class Foo implements Iterator
{
    /**
     * Store an array.
     *
     * @var array
     */
    private $property;

    /**
     * Store an array to the property.
     *
     * @param  array $array
     * @return void
     */
    public function __construct(array $array)
    {
        $this->property = $array;
    }

    /**
     * Print the current element of the specified property.
     *
     * @param  void
     * @return void
     */
    public function current()
    {
        var_dump('current: ' . current($this->property));
    }

    /**
     * Print the next element of the specified property and advance the internal pointer.
     *
     * @param  void
     * @return void
     */
    public function next()
    {
        var_dump('next: ' . next($this->property));
    }

    /**
     * Print the current key of the specified property.
     *
     * @param  void
     * @return void
     */
    public function key()
    {
        var_dump('key: ' . key($this->property));
    }

    /**
     * Check the current position of the specified property.
     *
     * @param  void
     * @return bool
     */
    public function valid(): bool
    {
        $valid = current($this->property) !== false;
        var_dump("valid: $valid");
        return $valid;
    }

    /**
     * Set the internal pointer of the specified property to the first element.
     *
     * @param  void
     * @return void
     */
    public function rewind()
    {
        var_dump('rewinding...');
        reset($this->property);
    }
}

$foo = new Foo([2, 4, 5]);
foreach ($foo as $key => $value) {
}
// string(12) "rewinding..."
// string(8) "valid: 1"
// string(10) "current: 2"
// string(6) "key: 0"
// string(7) "next: 4"
// string(8) "valid: 1"
// string(10) "current: 4"
// string(6) "key: 1"
// string(7) "next: 5"
// string(8) "valid: 1"
// string(10) "current: 5"
// string(6) "key: 2"
// string(6) "next: "
// string(7) "valid: "

```

可以用 `IteratorAggregate` 接口以替代实现所有的 `Iterator` 方法。 `IteratorAggregate` 只需要实现一个方法 `getIterator()` ，其应返回一个实现了 `Iterator` 的类的实例。

```php
<?php

declare(strict_types = 1);

class Foo implements Iterator
{
    /**
     * Store an array.
     *
     * @var array
     */
    private $property;

    /**
     * Store an array to the property.
     *
     * @param  array $array
     * @return void
     */
    public function __construct(array $array)
    {
        $this->property = $array;
    }

    /**
     * Print the current element of the specified property.
     *
     * @param  void
     * @return void
     */
    public function current()
    {
        var_dump('current: ' . current($this->property));
    }

    /**
     * Print the next element of the specified property and advance the internal pointer.
     *
     * @param  void
     * @return void
     */
    public function next()
    {
        var_dump('next: ' . next($this->property));
    }

    /**
     * Print the current key of the specified property.
     *
     * @param  void
     * @return void
     */
    public function key()
    {
        var_dump('key: ' . key($this->property));
    }

    /**
     * Check the current position of the specified property.
     *
     * @param  void
     * @return bool
     */
    public function valid(): bool
    {
        $valid = current($this->property) !== false;
        var_dump("valid: $valid");
        return $valid;
    }

    /**
     * Set the internal pointer of the specified property to the first element.
     *
     * @param  void
     * @return void
     */
    public function rewind()
    {
        var_dump('rewinding...');
        reset($this->property);
    }
}

class Bar implements IteratorAggregate
{
    /**
     * Store an array.
     *
     * @var array
     */
    private $property;

    /**
     * Store an array to the property.
     *
     * @param  array $array
     * @return void
     */
    public function __construct(array $array)
    {
        $this->property = $array;
    }

    /**
     * Return an external iterator.
     *
     * @param  void
     * @return Foo
     */
    public function getIterator(): Foo
    {
        return new Foo($this->property);
    }
}

$bar = new Bar([2, 4, 5]);
foreach ($bar as $key => $value) {
}
// string(12) "rewinding..."
// string(8) "valid: 1"
// string(10) "current: 2"
// string(6) "key: 0"
// string(7) "next: 4"
// string(8) "valid: 1"
// string(10) "current: 4"
// string(6) "key: 1"
// string(7) "next: 5"
// string(8) "valid: 1"
// string(10) "current: 5"
// string(6) "key: 2"
// string(6) "next: "
// string(7) "valid: "

```

