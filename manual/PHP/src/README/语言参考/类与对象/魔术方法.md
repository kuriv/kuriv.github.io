# 魔术方法

`__construct()` ， `__destruct()` ， `__call()` ， `__callStatic()` ， `__get()` ， `__set()` ， `__isset()` ， `__unset()` ， `__sleep()` ， `__wakeup()` ， `__toString()` ， `__invoke()` ， `__set_state()` ， `__clone()` 和 `__debugInfo()` 等方法在 `PHP` 中被称为魔术方法。在命名自己的类方法时不能使用这些方法名，除非是想使用其魔术功能。

`PHP` 允许开发者在一个类中定义一个方法作为构造函数。具有构造函数的类会在每次创建新对象时先调用此方法，所以非常适合在使用对象之前做一些初始化工作。

```php
<?php

declare(strict_types = 1);

class Foo
{
    /**
     * Just a test property.
     *
     * @var string
     */
    public $property;

    /**
     * Initialize the value of the property.
     *
     * @param  void
     * @return void
     */
    public function __construct()
    {
        $this->property = 'foo';
    }
}

$foo = new Foo;
var_dump($foo->property); // string(3) "foo"

```

`PHP` 引入了析构函数的概念，这类似于其它面向对象的语言，如 `C++` 。析构函数会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行。

```php
<?php

declare(strict_types = 1);

class Foo
{
    /**
     * Just a destructor.
     *
     * @param  void
     * @return void
     */
    public function __destruct()
    {
        var_dump('foo');
    }
}

$foo = new Foo;
unset($foo);
// string(3) "foo"

```

在对象中调用一个不可访问方法时， `__call()` 会被调用。

```php
<?php

declare(strict_types = 1);

class Foo
{
    /**
     * Return the specified string.
     *
     * @param  string $name
     * @param  array  $args
     * @return string
     */
    public function __call(string $name, array $args): string
    {
        return $name . implode('', $args);
    }
}

$foo = new Foo;
var_dump($foo->method('foo', 'bar')); // string(12) "methodfoobar"

```

在静态上下文中调用一个不可访问方法时， `__callStatic()` 会被调用。

```php
<?php

declare(strict_types = 1);

class Foo
{
    /**
     * Return the specified string.
     *
     * @param  string $name
     * @param  array  $args
     * @return string
     */
    public static function __callStatic(string $name, array $args): string
    {
        return $name . implode('', $args);
    }
}

var_dump(Foo::method('foo', 'bar')); // string(12) "methodfoobar"

```

在给不可访问属性赋值时， `__set()` 会被调用。

```php
<?php

declare(strict_types = 1);

class Foo
{
    /**
     * Set the specified property.
     *
     * @param string $name
     * @param string $value
     */
    public function __set(string $name, string $value)
    {
        $this->$name = $value;
    }
}

$foo = new Foo;
$foo->property = 'foo';
var_dump($foo->property); // string(3) "foo"

```

读取不可访问属性的值时， `__get()` 会被调用。

```php
<?php

declare(strict_types = 1);

class Foo
{
    /**
     * Private property.
     *
     * @var string
     */
    private $property = 'foo';

    /**
     * Return the specified property.
     *
     * @param  string $name
     * @return string
     */
    public function __get(string $name): string
    {
        return $this->$name;
    }
}

$foo = new Foo;
var_dump($foo->property); // string(3) "foo"

```

当对不可访问属性调用 `isset()` 或 `empty()` 时， `__isset()` 会被调用。

```php
<?php

declare(strict_types = 1);

class Foo
{
    /**
     * Private property.
     *
     * @var string
     */
    private $property = 'foo';

    /**
     * Returns whether the specified property is set.
     *
     * @param  string  $name
     * @return bool
     */
    public function __isset(string $name): bool
    {
        return isset($this->$name);
    }
}

$foo = new Foo;
var_dump(isset($foo->property)); // bool(true)

```

当对不可访问属性调用 `unset()` 时， `__unset()` 会被调用。

```php
<?php

declare(strict_types = 1);

class Foo
{
    /**
     * Private property.
     *
     * @var string
     */
    private $property = 'foo';

    /**
     * Returns whether the specified property is set.
     *
     * @param  string  $name
     * @return bool
     */
    public function __isset(string $name): bool
    {
        return isset($this->$name);
    }

    /**
     * Unset the specified property.
     *
     * @param  string $name
     * @return void
     */
    public function __unset(string $name)
    {
        unset($this->$name);
    }
}

$foo = new Foo;
var_dump(isset($foo->property)); // bool(true)
unset($foo->property);
var_dump(isset($foo->property)); // bool(false)

```

