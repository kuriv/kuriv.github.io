# 函数的参数

类型声明允许函数在调用时要求参数为特定类型。 如果给出的值类型不对，那么将会产生一个错误。为了指定一个类型声明，类型应该加到参数名前。这个声明可以通过将参数的默认值设为 `NULL` 来实现允许传递 `NULL` 。

| 类型        | 描述                               |
| ----------- | ---------------------------------- |
| 类/接口名称 | 参数必须是给定的类或实现接口的实例 |
| self        | 参数必须是与定义方法的类相同的实例 |
| array       | 参数必须是数组                     |
| callable    | 参数必须是可调用类型               |
| bool        | 参数必须是布尔类型                 |
| float       | 参数必须是浮点型                   |
| int         | 参数必须是整型                     |
| string      | 参数必须是字符串                   |

向函数传递数组：

```php
<?php

declare(strict_types = 1);

/**
 * Pass an array to the function.
 *
 * @param  array  $foo
 * @return void
 */
function foo(array $foo)
{
}

$foo = [2, 4, 5];
foo($foo);

```

通过引用传递函数参数：

```php
<?php

declare(strict_types = 1);

/**
 * Passing function parameters by reference.
 *
 * @param  array  &$foo
 * @return void
 */
function foo(array &$foo)
{
    unset($foo[1]);
}

$foo = [2, 4, 5];
foo($foo);

```

在函数中使用默认参数：

```php
<?php

declare(strict_types = 1);

/**
 * Use default parameters in function.
 *
 * @param  array       $foo
 * @param  string|null $bar
 * @return void
 */
function foo(array $foo = [], string $bar = null)
{
}

$foo = [2, 4, 5];
$bar = 'bar';
foo();
foo($foo);
foo($foo, null);
foo($foo, $bar);

```

基本类类型声明：

```php
<?php

declare(strict_types = 1);

/**
 * Basic class type declaration.
 *
 * @param  Foo    $instance
 * @return string
 */
function foo(Foo $instance): string
{
    return get_class($instance);
}

class Foo
{
}

class Bar extends Foo
{
}

class Baz
{
}

var_dump(foo(new Foo)); // string(3) "Foo"
var_dump(foo(new Bar)); // string(3) "Bar"
var_dump(foo(new Baz)); // PHP Fatal error:  Uncaught TypeError: Argument 1 passed to foo() must be an instance of Foo, instance of Baz given.

```

基本接口类型声明：

```php
<?php

declare(strict_types = 1);

/**
 * Basic interface type declaration.
 *
 * @param  Foo    $instance
 * @return string
 */
function foo(Foo $instance): string
{
    return get_class($instance);
}

interface Foo
{
}

class Bar implements Foo
{
}

class Baz
{
}

var_dump(foo(new Bar)); // string(3) "Bar"
var_dump(foo(new Baz)); // PHP Fatal error:  Uncaught TypeError: Argument 1 passed to foo() must implement interface Foo, instance of Baz given.

```

严格类型：

```php
<?php

declare(strict_types = 1);

/**
 * Calculate the sum of two integers.
 *
 * @param  int    $a
 * @param  int    $b
 * @return int
 */
function foo(int $a, int $b): int
{
    return $a + $b;
}

var_dump(foo(1, 2));     // int(3)
var_dump(foo(1.5, 2.5)); // PHP Fatal error:  Uncaught TypeError: Argument 1 passed to foo() must be of the type int, float given.

```

弱类型：

```php
<?php

/**
 * Calculate the sum of two integers.
 *
 * @param  int    $a
 * @param  int    $b
 * @return int
 */
function foo(int $a, int $b): int
{
    return $a + $b;
}

var_dump(foo(1, 2));     // int(3)
var_dump(foo(1.5, 2.5)); // int(3)

```

使用 `...` 来捕获函数参数：

```php
<?php

declare(strict_types = 1);

/**
 * Calculate the sum of all integers.
 *
 * @param  int $number
 * @return int
 */
function foo(int ...$number): int
{
    $sum = 0;
    foreach ($number as $value) {
        $sum += $value;
    }
    return $sum;
}

var_dump(foo(1, 2, 3, 4)); // int(10)

```

使用 `...` 来展开函数参数：

```php
<?php

declare(strict_types = 1);

/**
 * Calculate the sum of two integers.
 *
 * @param  int    $a
 * @param  int    $b
 * @return int
 */
function foo(int $a, int $b): int
{
    return $a + $b;
}

var_dump(foo(...[1, 2])); // int(3)

```

